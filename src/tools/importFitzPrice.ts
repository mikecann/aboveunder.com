import * as csvtojson from "csvtojson";
import { IPrintOption } from '../lib/types';
import * as fs from "fs";

interface ICSVRow
{
    Product: string;
    Width: string;
    Height: string;
    "Fitz Price": string;
    "My Price": string;
    Ratio: string;
    Area: string;
    Weight: string;
}

interface IProdMappings {
    [details: string] : { id:string, name:string };
} 

const prodMapping : IProdMappings = {
    "Metallic": { id:"photo-paper-poster", name:"Photo Paper Poster" },
    "Canvas": { id:"canvas", name:"Canvas" },
    "Acrylic": { id:"acrylic", name:"Acrylic" },
    "Matboard": { id:"matboard", name:"Matboard" },
    "Alumalux": { id:"alumalux", name:"Alumalux" },
    "Standard Frame": { id:"photo-paper-framed", name:"Photo Paper Framed" },
    "Frame": { id:"photo-paper-framed", name:"Photo Paper Framed" },
};

interface IOptions
{
    [details: string] : IPrintOption;
}

async function run() 
{
    const csvPath = `${__dirname}/../data/Above Under Pricing - Fitz Pricing.csv`;
    const tsPath = `${__dirname}/../src/lib/defaultPrintOptions.ts`;

    var options : IOptions = {};

    console.log(`Importing CSV from: ${csvPath}`);
    csvtojson()
        .fromFile(csvPath)
        .on('json', (json:ICSVRow) => {

            if (!json.Product)
                return;

            var mapping = prodMapping[json.Product];
            if (mapping==null)
                throw Error("No mapping found for: "+json.Product)

            if (!options.hasOwnProperty(mapping.id))
            {
                options[mapping.id] = {
                    id: prodMapping[json.Product].id,
                    name: prodMapping[json.Product].name,
                    sizes: []
                }
            }
            else
            {
                options[mapping.id].sizes.push({
                    id: `${json.Width}x${json.Height}`,
                    widthInches: parseInt(json.Width),
                    heightInches: parseInt(json.Height),
                    priceAUD: parseFloat(json["My Price"]),
                    weight: parseFloat(json.Weight) * 1000, // from kg to g
                })
            }
        })
        .on('done', async (error:any)=>{
            
            if (error)
                throw new Error(error);

            var outp = [];
            for(var key in options)
                outp.push(options[key]);

            fs.writeFileSync(tsPath, `// WARNING: This file has been generated by a tool!

import { IPrintOption } from "./types";
            
export const data : IPrintOption[] = ${JSON.stringify(outp, null, 2)};`)

        });
}

run();